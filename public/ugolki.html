<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>–£–≥–æ–ª–∫–∏ Multiplayer</title>
  <link rel="stylesheet" href="style.css">
  <link rel="icon" type="image/png" href="icon.png">
  <style>
    /* –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —Å—Ç–∏–ª–∏ —Ç–æ–ª—å–∫–æ –¥–ª—è —É–≥–æ–ª–∫–æ–≤ */
    .cell.target-white {
      box-shadow: inset 0 0 0 3px rgba(255, 255, 255, 0.6);
    }
    .cell.target-black {
      box-shadow: inset 0 0 0 3px rgba(0, 0, 0, 0.5);
    }
    .piece.jumping {
      box-shadow: 0 0 20px 5px rgba(0, 255, 100, 0.7) !important;
    }
    .rules-box {
      max-width: 420px;
      margin: 20px auto 0;
      padding: 15px 20px;
      background: rgba(255,255,255,0.07);
      border-radius: 12px;
      font-size: 0.9rem;
      line-height: 1.6;
      color: #ccc;
    }
    .rules-box h3 {
      margin-bottom: 10px;
      color: #ffd700;
      font-size: 1.1rem;
    }
    .rules-box ul {
      margin-left: 20px;
    }
    .rules-box li {
      margin-bottom: 5px;
    }
	      /* ===== –£–ì–û–õ–ö–ò: –≤–µ—Ä—Ö–Ω—è—è –ø–∞–Ω–µ–ª—å –≤ 3 –∫–æ–ª–æ–Ω–∫–∏, —Ç–∞–±–ª–æ —Å—Ç—Ä–æ–≥–æ –ø–æ —Ü–µ–Ω—Ç—Ä—É ===== */

    /* .topbar —Ç–æ–ª—å–∫–æ –Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü–µ —É–≥–æ–ª–∫–æ–≤ ‚Äî –¥–µ–ª–∞–µ–º —Å–µ—Ç–∫–æ–π 1fr auto 1fr */
    body.ugolki-page .topbar {
      display: grid;                     /* –ø–µ—Ä–µ–±–∏–≤–∞–µ–º flex –∏–∑ style.css */
      grid-template-columns: 1fr auto 1fr;
      align-items: center;
      /* —à–∏—Ä–∏–Ω—É –±–µ—Ä–µ–º –∫–∞–∫ –≤ –æ–±—â–µ–º —Å—Ç–∏–ª–µ, —á—Ç–æ–±—ã —Å–æ–≤–ø–∞–¥–∞–ª–∞ —Å –¥–æ—Å–∫–æ–π */
      width: 80vmin;
      max-width: 720px;
      margin: 12px auto 0;               /* –ø–æ —Ü–µ–Ω—Ç—Ä—É */
    }

    /* –õ–µ–≤—ã–π –∏ –ø—Ä–∞–≤—ã–π –∏–≥—Ä–æ–∫–∏ ‚Äî —É –∫—Ä–∞—ë–≤ —Å–≤–æ–∏—Ö –∫–æ–ª–æ–Ω–æ–∫ */
    body.ugolki-page .player-card.left {
      justify-self: start;
    }

    body.ugolki-page .player-card.right {
      justify-self: end;
      text-align: right;
      margin-left: 0;                    /* –ø–µ—Ä–µ–±–∏–≤–∞–µ–º margin-left:auto –∏–∑ style.css */
    }

    /* –¢–∞–±–ª–æ —Ö–æ–¥–∞ –ø–æ —Ü–µ–Ω—Ç—Ä—É –º–µ–∂–¥—É –∏–≥—Ä–æ–∫–∞–º–∏ */
    body.ugolki-page #turnDisplay {
      /* –ø–µ—Ä–µ–±–∏–≤–∞–µ–º –≥–ª–æ–±–∞–ª—å–Ω—ã–π #turnDisplay –∏–∑ style.css */
      margin-top: 0;
      width: auto;
      max-width: none;
      min-width: 0; /* –ü–æ–∑–≤–æ–ª—è–µ—Ç —Å–∂–∏–º–∞—Ç—å—Å—è */
      flex-shrink: 0; /* –ù–µ —Å–∂–∏–º–∞–µ—Ç—Å—è –º–µ–Ω—å—à–µ —Å–æ–¥–µ—Ä–∂–∏–º–æ–≥–æ */

      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      flex-wrap: nowrap; /* –ó–∞–ø—Ä–µ—Ç –ø–µ—Ä–µ–Ω–æ—Å–∞ */

      padding: 8px 14px;
      border-radius: 10px;
      background: rgba(0,0,0,0.3);
      border: 2px solid rgba(255,255,255,0.2);
      box-shadow: 0 4px 12px rgba(0,0,0,0.4);
      font-size: 1rem;
      white-space: nowrap; /* –ó–∞–ø—Ä–µ—Ç –ø–µ—Ä–µ–Ω–æ—Å–∞ —Ç–µ–∫—Å—Ç–∞ */
    }

    /* –£–±–µ–¥–∏–º—Å—è, —á—Ç–æ –∫–∞—Ä—Ç–æ—á–∫–∏ –∏–≥—Ä–æ–∫–æ–≤ –Ω–µ –≤—ã—Ö–æ–¥—è—Ç –∑–∞ –ø—Ä–µ–¥–µ–ª—ã */
    body.ugolki-page .player-card {
      min-width: 0; /* –ü–æ–∑–≤–æ–ª—è–µ—Ç —Å–∂–∏–º–∞—Ç—å—Å—è */
      overflow: hidden; /* –°–∫—Ä—ã–≤–∞–µ–º –≤—ã—Ö–æ–¥—è—â–∏–π –∫–æ–Ω—Ç–µ–Ω—Ç */
    }
    body.ugolki-page .player-lines {
      min-width: 0;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    body.ugolki-page .player-lines .name {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 100%;
    }
  </style>
</head>
<body class="ugolki-page">
<nav class="game-switch">
  <button class="game-switch__btn" id="goToCheckers">–®–∞—à–∫–∏</button>
  <span class="game-switch__label">–£–≥–æ–ª–∫–∏</span>
</nav>
<div class="controls">
  <button class="bubbly-button" id="createRoom">–°–æ–∑–¥–∞—Ç—å –∫–æ–º–Ω–∞—Ç—É</button>
  <button class="bubbly-button" id="rematch" disabled>–†–µ–º–∞—Ç—á</button>
  <button class="bubbly-button" id="invite" disabled>–ü—Ä–∏–≥–ª–∞—Å–∏—Ç—å –¥—Ä—É–≥–∞</button>

  <div class="volume-control-inline">
    <span style="font-size:20px">üîä</span>
    <input type="range" id="volumeSlider" min="0" max="100" value="50">
    <span id="volumeValue">50%</span>
  </div>

  <div id="toast" class="toast">—Å—Å—ã–ª–∫–∞ —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∞</div>
</div>

<div id="winnerBanner" class="winner-banner" style="display:none;"></div>

<div class="topbar" id="topbar" style="display:none;">
  <div class="player-card left" id="p1Card"></div>

  <!-- –¢–ê–ë–õ–û –•–û–î–ê –ü–û–°–ï–†–ï–î–ò–ù–ï -->
  <div class="turn-panel" id="turnDisplay">
    <span class="turn-label">–•–æ–¥:</span>
    <span id="turnColorBox"></span>
  </div>

  <div class="player-card right" id="p2Card"></div>
</div>

<div id="board"></div>

<!-- –ú–æ–¥–∞–ª–∫–∞ –≤—ã–±–æ—Ä–∞ –∏–º–µ–Ω–∏ –∏ –∞–≤–∞—Ç–∞—Ä–∞ -->
<div class="modal-backdrop" id="profileModalBackdrop">
  <div class="modal" role="dialog" aria-modal="true" aria-labelledby="profileTitle">
    <h2 id="profileTitle">–ò–º—è –∏–≥—Ä–æ–∫–∞ –∏ –∞–≤–∞—Ç–∞—Ä</h2>

    <div class="row">
      <label for="profileName">–ò–º—è:</label>
      <input id="profileName" placeholder="–í–∞—à –Ω–∏–∫" />
    </div>

    <div class="row" style="align-items:flex-start;">
      <div>
        <div style="font-weight:800; margin-bottom:6px;">–ê–≤–∞—Ç–∞—Ä:</div>
        <div class="avatar-grid" id="avatarGrid"></div>
      </div>
    </div>

    <div class="modal-actions">
      <button class="bubbly-button" id="profileOk">–û–ö</button>
    </div>
  </div>
</div>

<script>
// ==================== –£–ì–û–õ–ö–ò ====================
let roomId = null, playerColor = null, selectedPiece = null;
let seat = null;
let roomState = null;
let legalMoves = [];
let lastPlayedMoveId = 0;
let lastGameId = null;

const boardEl = document.getElementById('board');
const toastEl = document.getElementById('toast');
const winnerBannerEl = document.getElementById('winnerBanner');
const topbarEl = document.getElementById('topbar');
const p1Card = document.getElementById('p1Card');
const p2Card = document.getElementById('p2Card');

// Client ID (–æ—Ç–¥–µ–ª—å–Ω—ã–π –æ—Ç —à–∞—à–µ–∫)
const CLIENT_ID_KEY = 'ugolki_client_id_v1';
function getOrCreateClientId() {
  let v = sessionStorage.getItem(CLIENT_ID_KEY);
  if (v) return v;
  v = crypto?.randomUUID ? crypto.randomUUID() : (Date.now() + "_" + Math.random().toString(16).slice(2));
  sessionStorage.setItem(CLIENT_ID_KEY, v);
  return v;
}
const clientId = getOrCreateClientId();

// –ü—Ä–æ—Ñ–∏–ª—å
const PROFILE_NAME_KEY = (s) => `ugolki_profile_name_v1_seat_${s}`;
const PROFILE_AVATAR_KEY = (s) => `ugolki_profile_avatar_v1_seat_${s}`;
const AVATARS = ["üòÉ", "üòä", "üòà", "üëΩ", "ü§ñ", "üëª", "üòº", "ü¶ä", "üêØ", "ü¶Å", "üêâ", "üê•", "ü¶ã"];
let chosenAvatar = null;
let profileConfirmed = false;

function showToast(text) {
  if (!toastEl) return;
  toastEl.textContent = text;
  toastEl.classList.add('show');
  setTimeout(() => toastEl.classList.remove('show'), 2000);
}

function escapeHtml(str) {
  return (str || '').replace(/[&<>"']/g, (c) => ({
    '&': '&', '<': '<', '>': '>', '"': '"', "'": '&#39;'
  }[c]));
}

function truncateName(name) {
  if (!name) return '';
  if (name.length <= 10) return name;
  return name.substring(0, 10) + '...';
}

function seatKeyFromSeat(s) { return s === 1 ? 'p1' : (s === 2 ? 'p2' : null); }
function seatNumberFromKey(k) { return k === 'p1' ? 1 : (k === 'p2' ? 2 : null); }
function seatKeyForColor(state, color) {
  if (!state?.colors) return null;
  if (state.colors.p1 === color) return 'p1';
  if (state.colors.p2 === color) return 'p2';
  return null;
}

function makeMiniLoader() {
  return `
    <span class="mini-loader" aria-label="loading">
      <span class="bar1"></span><span class="bar2"></span><span class="bar3"></span>
      <span class="bar4"></span><span class="bar5"></span><span class="bar6"></span>
    </span>
    <span class="waiting-text">–æ–∂–∏–¥–∞–Ω–∏–µ –∏–≥—Ä–æ–∫–∞</span>
  `;
}

function renderPlayerCards(state) {
  if (!state || !roomId) {
    topbarEl.style.display = 'none';
    return;
  }
  topbarEl.style.display = 'flex';

  const p1 = state.profiles?.p1 || { avatar: 'üôÇ', name: '' };
  const p2 = state.profiles?.p2 || { avatar: 'üôÇ', name: '' };
  const p1Color = state.colors?.p1 || 'white';
  const p2Color = state.colors?.p2 || 'black';
  const p1ColorClass = p1Color === 'black' ? 'black' : 'white';
  const p2ColorClass = p2Color === 'black' ? 'black' : 'white';

  const p1Name = p1.name ? escapeHtml(truncateName(p1.name)) : '';
  const p2Name = p2.name ? escapeHtml(truncateName(p2.name)) : '';
  
  p1Card.innerHTML = `
    <span class="avatar">${p1.avatar || 'üôÇ'}</span>
    <span class="player-lines">
      <span class="title">–ò–≥—Ä–æ–∫ 1</span>
      ${p1Name ? `<span class="name">${p1Name}</span>` : ''}
    </span>
    <span class="color-box ${p1ColorClass}" title="–∫–æ–º–∞–Ω–¥–∞"></span>
  `;

  if (state.connected?.p2) {
    p2Card.innerHTML = `
      <span class="color-box ${p2ColorClass}" title="–∫–æ–º–∞–Ω–¥–∞"></span>
      <span class="player-lines" style="text-align:right;">
        <span class="title">–ò–≥—Ä–æ–∫ 2</span>
        ${p2Name ? `<span class="name">${p2Name}</span>` : ''}
      </span>
      <span class="avatar">${p2.avatar || 'üôÇ'}</span>
    `;
  } else {
    p2Card.innerHTML = makeMiniLoader();
  }
}

function setWinnerBanner(text) {
  if (!text) {
    winnerBannerEl.style.display = 'none';
    winnerBannerEl.textContent = '';
    return;
  }
  winnerBannerEl.textContent = text;
  winnerBannerEl.style.display = 'block';
}

function clearMoveDots() {
  document.querySelectorAll('.move-dot').forEach(el => el.remove());
}

function renderMoveDots(destinations) {
  clearMoveDots();
  for (const { x, y } of destinations) {
    const cell = boardEl.querySelector(`.cell[data-x='${x}'][data-y='${y}']`);
    if (!cell) continue;
    const dot = document.createElement('div');
    dot.className = 'move-dot';
    cell.appendChild(dot);
  }
}

// –¶–µ–ª–µ–≤—ã–µ –∑–æ–Ω—ã
function getTargetZone(color) {
  const zone = [];
  if (color === 'white') {
    // –ë–µ–ª—ã–µ –¥–æ–ª–∂–Ω—ã –∑–∞–Ω—è—Ç—å –ª–µ–≤—ã–π –≤–µ—Ä—Ö–Ω–∏–π —É–≥–æ–ª
    for (let y = 0; y < 3; y++) for (let x = 0; x < 3; x++) zone.push({ x, y });
  } else {
    // –ß—ë—Ä–Ω—ã–µ –¥–æ–ª–∂–Ω—ã –∑–∞–Ω—è—Ç—å –ø—Ä–∞–≤—ã–π –Ω–∏–∂–Ω–∏–π —É–≥–æ–ª
    for (let y = 5; y < 8; y++) for (let x = 5; x < 8; x++) zone.push({ x, y });
  }
  return zone;
}

// –í—ã—á–∏—Å–ª–µ–Ω–∏–µ –≤–æ–∑–º–æ–∂–Ω—ã—Ö —Ö–æ–¥–æ–≤
function getUgolkiMoves(board, pos) {
  const piece = board?.[pos.y]?.[pos.x];
  if (!piece) return { steps: [], jumps: [] };

  const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];
  const inBounds = (x, y) => x >= 0 && x < 8 && y >= 0 && y < 8;
  const steps = [];
  const jumps = [];

  for (const [dx, dy] of directions) {
    const nx = pos.x + dx;
    const ny = pos.y + dy;
    if (!inBounds(nx, ny)) continue;

    if (!board[ny][nx]) {
      steps.push({ x: nx, y: ny });
    } else {
      const jx = pos.x + 2 * dx;
      const jy = pos.y + 2 * dy;
      if (inBounds(jx, jy) && !board[jy][jx]) {
        jumps.push({ x: jx, y: jy });
      }
    }
  }

  return { steps, jumps };
}

function computeLegalDestinations(board, playerColor, selectedPiece, roomState) {
  if (!roomState || !selectedPiece) return [];
  if (roomState.turn !== playerColor) return [];
  if (roomState.winner) return [];

  const piece = board?.[selectedPiece.y]?.[selectedPiece.x];
  if (!piece || piece.color !== playerColor) return [];

  // –ï—Å–ª–∏ –≤ –ø—Ä–æ—Ü–µ—Å—Å–µ —Å–µ—Ä–∏–∏ –ø—Ä—ã–∂–∫–æ–≤ ‚Äî –º–æ–∂–Ω–æ —Ç–æ–ª—å–∫–æ —ç—Ç–æ–π —à–∞—à–∫–æ–π –∏ —Ç–æ–ª—å–∫–æ –ø—Ä—ã–∂–∫–∏
  if (roomState.jumpingFrom) {
    if (selectedPiece.x !== roomState.jumpingFrom.x || selectedPiece.y !== roomState.jumpingFrom.y) {
      return [];
    }
    const { jumps } = getUgolkiMoves(board, selectedPiece);
    return jumps;
  }

  const { steps, jumps } = getUgolkiMoves(board, selectedPiece);
  return [...steps, ...jumps];
}

function createBoardUI() {
  boardEl.innerHTML = '';
  const whiteTarget = getTargetZone('white');
  const blackTarget = getTargetZone('black');

  for (let y = 0; y < 8; y++) {
    for (let x = 0; x < 8; x++) {
      const c = document.createElement('div');
      // –í—Å–µ –∫–ª–µ—Ç–∫–∏ –æ–¥–Ω–æ–≥–æ —Ü–≤–µ—Ç–∞ (–∫–∞–∫ —à–∞—Ö–º–∞—Ç–Ω–∞—è –¥–æ—Å–∫–∞, –Ω–æ –¥–ª—è —É–≥–æ–ª–∫–æ–≤ –º–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —á–µ—Ä–µ–¥–æ–≤–∞–Ω–∏–µ)
      c.className = 'cell ' + ((x + y) % 2 === 0 ? 'white' : 'black');
      c.dataset.x = x;
      c.dataset.y = y;

      // –ü–æ–¥—Å–≤–µ—Ç–∫–∞ —Ü–µ–ª–µ–≤—ã—Ö –∑–æ–Ω
      if (whiteTarget.some(t => t.x === x && t.y === y)) {
        c.classList.add('target-white');
      }
      if (blackTarget.some(t => t.x === x && t.y === y)) {
        c.classList.add('target-black');
      }

      boardEl.appendChild(c);
    }
  }
}

function renderBoard(board) {
  createBoardUI();
  for (let y = 0; y < 8; y++) {
    for (let x = 0; x < 8; x++) {
      const p = board?.[y]?.[x];
      if (p) {
        const cell = boardEl.querySelector(`.cell[data-x='${x}'][data-y='${y}']`);
        const el = document.createElement('div');
        el.className = 'piece ' + p.color;
        
        if (selectedPiece && selectedPiece.x === x && selectedPiece.y === y) {
          el.classList.add('selected');
        }
        // –ü–æ–¥—Å–≤–µ—Ç–∫–∞ —à–∞—à–∫–∏ –≤ –ø—Ä–æ—Ü–µ—Å—Å–µ –ø—Ä—ã–∂–∫–æ–≤
        if (roomState?.jumpingFrom && roomState.jumpingFrom.x === x && roomState.jumpingFrom.y === y) {
          el.classList.add('jumping');
        }
        cell.appendChild(el);
      }
    }
  }
  renderMoveDots(legalMoves);
}

function startPolling() {
  setInterval(async () => {
    if (!roomId) return;
    const r = await fetch(`/ugolki/room/${roomId}/state`);
    const d = await r.json();

    // Rematch
    if (typeof d.gameId === 'number' && lastGameId != null && d.gameId !== lastGameId) {
      await joinRoomById(roomId, { showModal: false, keepProfileConfirmed: true });
      selectedPiece = null;
      legalMoves = [];
      clearMoveDots();
      setWinnerBanner(null);
      lastPlayedMoveId = 0;
    }
    if (typeof d.gameId === 'number') lastGameId = d.gameId;

    // –ó–≤—É–∫–∏ –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞
    if (d.lastMoveId && d.lastMoveId > lastPlayedMoveId) {
      if (d.lastMoveBy && d.lastMoveBy !== playerColor && d.lastMoveSound) {
        playSound(d.lastMoveSound);
      }
      lastPlayedMoveId = d.lastMoveId;
    }

    roomState = d;

    // –ò–Ω–¥–∏–∫–∞—Ç–æ—Ä —Ö–æ–¥–∞
    const colorBox = document.getElementById('turnColorBox');
    if (colorBox) {
      if (roomState.turn === 'white') {
        colorBox.style.backgroundColor = '#ffffff';
        colorBox.style.border = '1px solid #000000';
      } else {
        colorBox.style.backgroundColor = '#000000';
        colorBox.style.border = '1px solid #ffffff';
      }
    }

    // –°–±—Ä–æ—Å –≤—ã–¥–µ–ª–µ–Ω–∏—è –µ—Å–ª–∏ –Ω–µ –Ω–∞—à —Ö–æ–¥
    if (!playerColor || roomState.turn !== playerColor) {
      selectedPiece = null;
      legalMoves = [];
    }

    // –ê–≤—Ç–æ–≤—ã–±–æ—Ä —à–∞—à–∫–∏ –ø—Ä–∏ —Å–µ—Ä–∏–∏ –ø—Ä—ã–∂–∫–æ–≤
    if (playerColor && roomState.jumpingFrom && roomState.turn === playerColor) {
      selectedPiece = { x: roomState.jumpingFrom.x, y: roomState.jumpingFrom.y };
    }

    legalMoves = (playerColor && selectedPiece)
      ? computeLegalDestinations(roomState.board, playerColor, selectedPiece, roomState)
      : [];

    // –ü–æ–±–µ–¥–∞
    if (roomState.winner) {
      const winnerSeatKey = seatKeyForColor(d, roomState.winner);
      const winnerSeatNum = seatNumberFromKey(winnerSeatKey);
      const winnerProfile = winnerSeatKey ? (d.profiles?.[winnerSeatKey] || { name: '' }) : { name: '' };
      const displayName = (winnerProfile?.name && winnerProfile.name.trim())
        ? winnerProfile.name.trim()
        : (winnerSeatNum ? `–ò–≥—Ä–æ–∫ ${winnerSeatNum}` : '–ò–≥—Ä–æ–∫');
      setWinnerBanner(`üèÜ –ü–æ–±–µ–¥–∏–ª "${displayName}"`);
      legalMoves = [];
      selectedPiece = null;
    } else {
      setWinnerBanner(null);
    }

    renderPlayerCards(d);
    document.getElementById('invite').disabled = !roomId;
    document.getElementById('rematch').disabled = !roomId;
    renderBoard(d.board);
  }, 500);
}

// Profile modal
function showProfileModal(defaultName) {
  const backdrop = document.getElementById('profileModalBackdrop');
  const nameInput = document.getElementById('profileName');
  const grid = document.getElementById('avatarGrid');
  if (!backdrop || !nameInput || !grid) return;

  const titleEl = document.getElementById('profileTitle');
  if (titleEl) titleEl.textContent = `–ò–º—è –∏–≥—Ä–æ–∫–∞ –∏ –∞–≤–∞—Ç–∞—Ä (${defaultName})`;

  let savedName = seat ? localStorage.getItem(PROFILE_NAME_KEY(seat)) || '' : '';
  nameInput.value = savedName;

  let savedAvatar = seat ? localStorage.getItem(PROFILE_AVATAR_KEY(seat)) || '' : '';
  chosenAvatar = savedAvatar && AVATARS.includes(savedAvatar) ? savedAvatar : AVATARS[Math.floor(Math.random() * AVATARS.length)];

  grid.innerHTML = '';
  for (const a of AVATARS) {
    const el = document.createElement('div');
    el.className = 'avatar-choice' + (a === chosenAvatar ? ' selected' : '');
    el.textContent = a;
    el.onclick = () => {
      chosenAvatar = a;
      grid.querySelectorAll('.avatar-choice').forEach(x => x.classList.remove('selected'));
      el.classList.add('selected');
    };
    grid.appendChild(el);
  }

  backdrop.classList.add('show');
  setTimeout(() => nameInput.focus(), 0);
}

async function submitProfile() {
  if (!roomId || !playerColor) return;
  const name = (document.getElementById('profileName')?.value || '').trim();
  const avatar = (chosenAvatar || '').trim();

  if (seat) {
    localStorage.setItem(PROFILE_NAME_KEY(seat), name);
    localStorage.setItem(PROFILE_AVATAR_KEY(seat), avatar);
  }

  const r = await fetch(`/ugolki/room/${roomId}/profile`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ clientId, name, avatar })
  });
  const d = await r.json();
  if (d?.error) {
    alert(d.error);
    return;
  }
  profileConfirmed = true;
  document.getElementById('profileModalBackdrop')?.classList.remove('show');

  const sk = seatKeyFromSeat(seat);
  if (sk && roomState) {
    if (!roomState.profiles) roomState.profiles = {};
    roomState.profiles[sk] = d.profile;
    if (!roomState.connected) roomState.connected = {};
    if (sk === 'p1') roomState.connected.p1 = true;
    if (sk === 'p2') roomState.connected.p2 = true;
    renderPlayerCards(roomState);
  }
}

function getRoomIdFromUrl() {
  const u = new URL(location.href);
  return (u.searchParams.get('room') || '').trim() || null;
}

async function joinRoomById(id, opts = {}) {
  const { showModal = true, keepProfileConfirmed = false } = opts;
  const r = await fetch(`/ugolki/room/${id}/join?clientId=${encodeURIComponent(clientId)}`);
  const d = await r.json();
  if (d.error) return { error: d.error };
  roomId = id;
  playerColor = d.color;
  seat = d.seat;
  profileConfirmed = keepProfileConfirmed ? profileConfirmed : false;
  if (playerColor === 'black') boardEl.classList.add('flipped');
  else boardEl.classList.remove('flipped');
  document.getElementById('invite').disabled = false;
  document.getElementById('rematch').disabled = false;
  if (showModal) showProfileModal(seat === 1 ? '–ò–≥—Ä–æ–∫ 1' : '–ò–≥—Ä–æ–∫ 2');
  return { ok: true };
}

// –ê–Ω–∏–º–∞—Ü–∏—è –∫–Ω–æ–ø–æ–∫
function applyBubblyButtonAnimations() {
  const animateButton = function(e) {
    e.preventDefault();
    e.target.classList.remove('animate');
    e.target.classList.add('animate');
    setTimeout(() => e.target.classList.remove('animate'), 700);
  };
  const bubblyButtons = document.getElementsByClassName('bubbly-button');
  for (let i = 0; i < bubblyButtons.length; i++) {
    bubblyButtons[i].addEventListener('click', animateButton, false);
  }
}

	
// Event handlers
document.getElementById('createRoom').onclick = async () => {
  const r = await fetch('/ugolki/room/create');
  const d = await r.json();
  roomId = d.roomId;
  const j = await joinRoomById(roomId, { showModal: true });
  if (j.error) return;
};

	document.getElementById('goToCheckers').onclick = () => {
  // –ø–æ–º–µ–Ω—è–π 'index.html' –Ω–∞ —Ä–µ–∞–ª—å–Ω–æ–µ –∏–º—è —Å—Ç—Ä–∞–Ω–∏—Ü—ã —à–∞—à–µ–∫
  window.location.href = 'index.html';
};

document.getElementById('invite').onclick = async () => {
  if (!roomId) return;
  const url = `${location.origin}/ugolki.html?room=${encodeURIComponent(roomId)}`;
  try {
    await navigator.clipboard.writeText(url);
    showToast('—Å—Å—ã–ª–∫–∞ —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∞');
  } catch {
    const tmp = document.createElement('textarea');
    tmp.value = url;
    document.body.appendChild(tmp);
    tmp.select();
    document.execCommand('copy');
    tmp.remove();
    showToast('—Å—Å—ã–ª–∫–∞ —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∞');
  }
};

document.getElementById('rematch').onclick = async () => {
  if (!roomId) return;
  await fetch(`/ugolki/room/${roomId}/rematch`, { method: 'POST' });
  await joinRoomById(roomId, { showModal: false, keepProfileConfirmed: true });
  setWinnerBanner(null);
  selectedPiece = null;
  legalMoves = [];
  clearMoveDots();
};

document.getElementById('profileOk').onclick = submitProfile;
document.getElementById('profileName')?.addEventListener('keydown', (e) => {
  if (e.key === 'Enter') submitProfile();
});

// Board click
boardEl.addEventListener('click', async e => {
  const cell = e.target.closest('.cell');
  if (!cell || !playerColor) return;
  if (!profileConfirmed) return;
  if (roomState?.winner) return;

  const x = +cell.dataset.x, y = +cell.dataset.y;
  const piece = cell.querySelector('.piece');

  // –í—ã–±–æ—Ä —Å–≤–æ–µ–π —à–∞—à–∫–∏
  if (piece && piece.classList.contains(playerColor)) {
    if (!roomState || roomState.turn !== playerColor) return;

    // –ï—Å–ª–∏ –≤ –ø—Ä–æ—Ü–µ—Å—Å–µ —Å–µ—Ä–∏–∏ –ø—Ä—ã–∂–∫–æ–≤ ‚Äî –º–æ–∂–Ω–æ –≤—ã–±—Ä–∞—Ç—å —Ç–æ–ª—å–∫–æ —Ç—É —à–∞—à–∫—É
    if (roomState.jumpingFrom) {
      if (x !== roomState.jumpingFrom.x || y !== roomState.jumpingFrom.y) return;
    }

    document.querySelectorAll('.piece.selected').forEach(p => p.classList.remove('selected'));
    piece.classList.add('selected');
    selectedPiece = { x, y };

    legalMoves = computeLegalDestinations(roomState.board, playerColor, selectedPiece, roomState);
    renderMoveDots(legalMoves);
    return;
  }

  // –•–æ–¥
  if (selectedPiece) {
    const isLegal = legalMoves.some(m => m.x === x && m.y === y);
    if (!isLegal) return;

    const r = await fetch(`/ugolki/room/${roomId}/move`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ from: selectedPiece, to: { x, y }, player: playerColor })
    });
    const d = await r.json();

    if (d.error) {
      showToast(d.error);
      return;
    }

    // –ó–≤—É–∫
    if (d.lastMoveSound) {
      playSound(d.lastMoveSound);
    }
    if (d.lastMoveId) {
      lastPlayedMoveId = d.lastMoveId;
    }

    // –û–±–Ω–æ–≤–ª—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ
    if (d.board) roomState = { ...(roomState || {}), board: d.board };
    if (typeof d.turn === 'string') roomState.turn = d.turn;
    roomState.jumpingFrom = d.jumpingFrom;
    roomState.lastActionAt = Date.now();

    // –ï—Å–ª–∏ –º–æ–∂–Ω–æ –ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å –ø—Ä—ã–∂–∫–∏
    if (d.jumpingFrom) {
      selectedPiece = { x: d.jumpingFrom.x, y: d.jumpingFrom.y };
      legalMoves = computeLegalDestinations(d.board, playerColor, selectedPiece, roomState);
      renderBoard(d.board);
      return;
    }

    // –•–æ–¥ –æ–∫–æ–Ω—á–µ–Ω
    selectedPiece = null;
    legalMoves = [];
    clearMoveDots();
    if (d.board) renderBoard(d.board);
  }
});

createBoardUI();
startPolling();
applyBubblyButtonAnimations();

// Auto-join by URL
(async () => {
  const fromUrl = getRoomIdFromUrl();
  if (fromUrl) {
    const j = await joinRoomById(fromUrl);
    if (j.error) alert(j.error);
  }
})();
</script>

<script>
// === –ó–í–£–ö–ò ===
const sounds = {
  move: new Audio('sounds/woosh.mp3'),
  capture: new Audio('sounds/woosh.mp3'),
  king: new Audio('sounds/king.mp3')
};

let volume = 0.5;

function setVolume(val) {
  volume = val;
  Object.values(sounds).forEach(s => s.volume = val);
  document.getElementById('volumeValue').textContent = Math.round(val * 100) + '%';
}

let soundReady = false;
document.addEventListener('click', () => {
  if (soundReady) return;
  sounds.move.play().catch(() => {});
  soundReady = true;
}, { once: true });

document.getElementById('volumeSlider').addEventListener('input', (e) => {
  setVolume(e.target.value / 100);
});

setVolume(0.5);

function playSound(type) {
  if (!soundReady || !sounds[type]) return;
  const s = sounds[type];
  s.currentTime = 0;
  s.volume = volume;
  s.play().catch(() => {});
}
</script>

</body>
</html>